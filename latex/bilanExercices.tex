\chapter{Bilan des exercices}

\section{Prédicats}

La particularité de Prolog réside dans le fait qu'il n'y a pas d'itérations comme
un langage de programmation conventionnel, tout n'est que prédicat. Ainsi, la
méthode de programmation est très différente. Il n'y a pas de traitement de données
dans des variables que l'on met à jour, car la programmation par prédicats permet
simplement de lier des propriétés entre des variables et/ou constantes.

Considérons pour la suite, le prédicat
\[(membre(X, L) \Leftrightarrow vrai) \Leftrightarrow X \in L\]


\section{Vérification de propriétés}

La vérification de propriétés permet de s'assurer qu'une (ou plusieurs) constantes
vérifient un ensemble de prédicats. Considérons le code énoncé précédemment.

Alors on a à l'exécution

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, [1, 2, 3]).
true

?- membre(4, [1, 2, 3]).
false
\end{lstlisting}

En effet, à la première interrogation, on vérifie le prédicat $1 \in [1, 2, 3]$,
cette propriété est vérifiée, d'où la réponse de Prolog «~\textit{true}~». Tandis que la seconde interrogation $4 \in [1, 2, 3]$ est fausse car 
$4 \notin [1, 2, 3]$, d'où la réponse «~\textit{false}~».


\section{Recherche de solutions}

La recherche de solution consiste à définir des propriétés entre des
objects et/ou constantes. Par exemple
\[
	X \in [1, 2, 3]
\]

 Ce qui en Prolog donne
\begin{lstlisting}[language=Prolog,frame=single]
?- membre(X, [1, 2, 3]).
\end{lstlisting}

Ainsi a l'éxécution, Prolog est capable d'évaluer les solutions de $X$ grace a
la définition précédente du prédicat membre

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(X, [1, 2, 3]).
X = 1;
X = 2;
X = 3;
false
\end{lstlisting}


\section{Recherche de solutions d'un système}

Les propriétés d'une variable par exemple, peuvent être définies par plusieurs
prédicats. Par exemple
\[
    \left\{  
    \begin{array}{c}
        L \in [1, 2, 3]\\
        L \in [3, 4, 2]\\
    \end{array}
    \right .
\]

Peut revenir simplement en Prolog à
\begin{lstlisting}[language=Prolog,frame=single]
?- membre(X, [1, 2, 3]), membre(X, [3, 4, 2]).
X = 2;
X = 3;
false
\end{lstlisting}


\section{Recherche de solutions non-déterministes}

Le risque encouru lors de la recherche de solution(s), est qu'il est possible qu'une
infinité de solutions vérifie une même propriété. Considérons par exemple
le code suivant

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, L).
\end{lstlisting}

Qui est équivalent à $1 \in L$. Cherchons à déterminer combien de listes
pourraient vérifier cette propriété :

\textbf{Initialisation}~: La liste $[1, 2]$ par exemple vérifie cette propriété.

\textbf{Hérédité}~: En notant $cat(A, B)$ la concaténation de deux listes $A$ et
$B$,\\
Soit une liste $L$ telle que $1 \in L$,\\
Alors $\forall X \in \mathbb{N} / 1 \in cat([X], L)$

\textbf{Conclusion}~: Il existe une infinité de solutions et Prolog va essayer
de toutes les générer, causant une exception due au manque de mémoire de la
machine.

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, L).
L = [1|_G2214] ;
L = [_G2213, 1|_G2217] ;
L = [_G2213, _G2216, 1|_G2220] ;
L = [_G2213, _G2216, _G2219, 1|_G2223] ;
L = [_G2213, _G2216, _G2219, _G2222, 1|_G2226] ;
L = [_G2213, _G2216, _G2219, _G2222, _G2225, 1|_G2229] ;
...
\end{lstlisting}


\section{Programmation de prédicats triviaux}

Auparavant, nous nous contentions d'utiliser des prédicats, mais, bien entendu,
l'objectif est de pouvoir en coder soi-même. C'est ici que la méthode de programmation diffère
complétement de la programmation itérative. Nous devons procéder avec une démarche
d'analyse mathématique. Pour cela, intéressons-nous à la ré-écriture de
\[(membre(X, L) \Leftrightarrow vrai) \Leftrightarrow X \in L\]

Tout d'abord, on peut remarquer que si $X$ se trouve en tête de $L$ alors il appartient de manière évidente à cette liste. Autrement dit $X \in [X, ...]$, ou encore
$X \in (L = cat([X], L1))$ avec $L1$ une autre liste. Alors on en déduit le
premier prédicat 
\begin{lstlisting}[language=Prolog,frame=single]
membre(X, [X|_]).
\end{lstlisting}

On remarque par ailleurs que si $X$ n'est pas en tête de la liste recherchée, alors il faut vérifier s'il n'est pas en tête de la sous-liste associée au retrait de cette tête, 
\[\forall (X, Y) \in \mathbb{E}^2, X \in L \Rightarrow X \in cat([Y], L)\]
Ainsi on en déduit le second prédicat
\begin{lstlisting}[language=Prolog,frame=single]
membre(X, [_|L]) :- membre(X, L).
\end{lstlisting}


\section{Prédicats avec calculs arithmétiques}

On se propose d'implémenter un prédicat permettant de vérifier un élement à une
position donnée dans une liste : $X = L[I]$

Exemple :
\begin{lstlisting}[language=Prolog,frame=single]
?- elementAtPos(2, hello, [hi, hello, bye]).
true

?- elementAtPos(3, hi, [hi, hello, bye]).
false
\end{lstlisting}


Tout d'abord, le premier cas évidents survient lorsque la liste $L$ est vide, le
prédicat doit alors être faux puisqu'aucun élément ne peut exister dans une liste vide~:
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(_, _, []) :- fail.
\end{lstlisting}
Notez que cette ligne est facultative, car définir un prédicat comme échouant
(fail) reviens à ne pas le définir. Nous illustrons ici simplement la démarche que nous avons suivis.

Viens ensuite le cas évident où nous voulons tester le premier élément de la
liste.
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(1, X, [X|_]).
\end{lstlisting}

Enfin, il demeure le cas où $X$ n'est pas le premier élément. Alors, l'idee, est
de récursivement prouver $elementAtPos/3$ mais en retirant le premier élément de la liste $L$
a chaque fois~:
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(I, X, [_|L]) :-
    I1 is I-1, elementAtPos(I1, X, L).
\end{lstlisting}
Vous aurez remarqué ici la présence d'un index $I$ qui est décrémenté dans $I1$. En effet, le système de récursion marche de telle sorte que lorsqu'une solution sera trouvée via le cas évident, si elle est trouvée, alors la valeur $I1$ de l'avant dernier appel récursif sera égal à 1, et donc il pourra être vu comme 
\[
elementAtPos(I, X, [\_|L]) :-\ \ 1\ is\ I-1,\ elementAtPos(1, X, L).
\] et ainsi de suite, la valeur de $I$ dépendra donc de la profondeur de la récursion nécessaire, or comme la tête de la liste est enlevée à chaque récursion cela correspond bien à un index de la liste. 

\section{Recherche avec calculs arithmétiques}

Avec le prédicat $elementAtPos/3$ défini ci dessus, il est alors facile de l'utiliser pour rechercher
un élément $X$ à une position $I$ dans une liste $L$.
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(2, X, [10, 11, 12]).
X = 11 ;
false
\end{lstlisting}

Cependant si nous cherchons l'index $I$ d'un élément
$X$ donné et dans une liste $L$ donnée, il survient une erreur spéciale.
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(I, 12, [10, 12]).
ERROR: >/2: Arguments are not sufficiently instantiated
\end{lstlisting}

En effet si nous déroulons les prédicats, nous obtenons alors~:
\begin{lstlisting}[language=Prolog,frame=single]
elementAtPos(I, 12, [10, 12]) :-
    I1 is I - 1, elementAtPos(I1, 12, [12]).
elementAtPos(I, 12, [10, 12]) :- elementAtPos(I - 1, 12, [12]).
\end{lstlisting}

Ainsi nous voyons l'expression $I - 1$ tente de vérifier une propriété liée par le prédicat
$elementAtPos/3$. Cela génère une erreur car elle est une variable non liée (unbound variable).

En effet, cette erreur peut etre facilement reproduite par~:
\begin{lstlisting}[language=Prolog,frame=single]
?- elementAtPos(I + 2, 11, [10, 11, 12]).
ERROR: elementAtPos/3: Arguments are not sufficiently instantiated
\end{lstlisting}
