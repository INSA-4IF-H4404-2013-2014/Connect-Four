
\chapter{Bilan des éxercices}

\section{Predicats}

La particularite Prolog reside dans le fait qu'il n'y a plus d'iterations comme
un language de programmation conventionnel. Tout n'est que predicat. Ainsi, la
methode de programmation change de facon de penser. Fini le traitement de donnes
dans des variable que l'on met jour, car la programmation predicat permet
simplement de lier des proprietes entre des variables et/ou constantes.

Considerons pour la suite, le predicat :
\begin{center}
$member(X, L)$ vrai si et seulement si $X \in L$.
\end{center}


\section{Vérification de propriétés}

La vérification de propriétés permet s'assurer que une (out plusieur) constantes
verifies un ensemble de predicat. Considerons le code ci dessous :

Alors on a à l'éxécution :

\begin{lstlisting}[language=Prolog]
?- membre(1, [1, 2, 3]).
true

?- membre(4, [1, 2, 3]).
false
\end{lstlisting}

En effet, a la premiere intérogation, on vérifie le prédicat $1 \in [1, 2, 3]$
ce qui est vrai, d'ou la reponse de Prolog 'vrai'. La proprieté etre ces deux
paramêtres est alors vérifié, renvoyant ainsi vrai. Tandis que la seconde
interogation $4 \in [1, 2, 3]$ est fausse car $4 \notin [1, 2, 3]$, d'ou la
reponse 'false'.


\section{Reprouvabilitée}

La reprouvabilitees consiste maintenant de definir des propriete entre des
variables et/ou constantes. Par exemple :
\begin{center}
$X \in [1, 2, 3]$.
\end{center}

 Ce qui en Prolog donne :
\begin{lstlisting}[language=Prolog]
?- membre(X, [1, 2, 3]).
\end{lstlisting}

On lis a ce moment que $X$ compose la liste constante $[1, 2, 3]$. Ainsi a
l'execution, Prolog peut evaluer les solutions de $L$ grace a cette proprietee
ainsi définie :

\begin{lstlisting}[language=Prolog]
?- membre(L, [1, 2, 3]).
L = 1;
L = 2;
L = 3;
false
\end{lstlisting}


\section{Reprouvabilitée non-déterministe}

La dangeureusitee de de la reprouvabilitée, est qu'il est possible qu'une
infinitée de solutions vérifient une meme propriétée. Considerons par exemple
le code suivant~:

\begin{lstlisting}[language=Prolog]
?- membre(1, L).
\end{lstlisting}

Cette est equivalent à $1 \in L$. Mais alors, combien de listes
pourraient vérifié cette propriété ?

\textbf{Initialisation}~: Une liste telle que $[1, 2]$ vérifie cette propriété.

\textbf{Hérédité}~: En notant $cat(A, B)$ la concatenation de deux listes $A$ et
$B$,\\
Soit une liste $L$ telle que $1 \in L$,\\
Alors $\forall X \in \mathbb{N} / 1 \in cat([X], L)$

\textbf{Conclusion}~: Il éxiste une infinité de solutions et Prolog va essayer
de toutes les générer, causant une exception du au manque de mémoire de la
machine.

\begin{lstlisting}[language=Prolog]
?- membre(1, L).
L = [1|_G2214] ;
L = [_G2213, 1|_G2217] ;
L = [_G2213, _G2216, 1|_G2220] ;
L = [_G2213, _G2216, _G2219, 1|_G2223] ;
L = [_G2213, _G2216, _G2219, _G2222, 1|_G2226] ;
L = [_G2213, _G2216, _G2219, _G2222, _G2225, 1|_G2229] ;
...
\end{lstlisting}
