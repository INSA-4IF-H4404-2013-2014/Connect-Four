\chapter{Bilan des exercices}

\section{Prédicats}

La particularité de Prolog réside dans le fait qu'il n'y a plus d'itérations comme
un langage de programmation conventionnel. Tout n'est que prédicat. Ainsi, la
méthode de programmation est très différente. Fini le traitement de données
dans des variables que l'on met à jour, car la programmation par prédicats permet
simplement de lier des propriétés entre des variables et/ou constantes.

Considérons pour la suite, le prédicat~:
\[(membre(X, L) \Leftrightarrow vrai) \Leftrightarrow X \in L\]


\section{Vérification de propriétés}

La vérification de propriétés permet de s'assurer qu'une (ou plusieurs) constantes
vérifient un ensemble de prédicats. Considérons le code ci-dessus.

Alors on a à l'exécution~:

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, [1, 2, 3]).
true

?- membre(4, [1, 2, 3]).
false
\end{lstlisting}

En effet, à la première interrogation, on vérifie le prédicat $1 \in [1, 2, 3]$,
ce qui est vrai, d'où la réponse de Prolog «~\textit{true}~». La propriété est alors vérifiée, 
renvoyant ainsi vrai. Tandis que la seconde interogation $4 \in [1, 2, 3]$ est fausse car 
$4 \notin [1, 2, 3]$, d'où la réponse «~\textit{false}~».


\section{Reprouvabilité}

La reprouvabilité consiste à définir des propriétés entre des
variables et/ou constantes. Par exemple~:
\[
	X \in [1, 2, 3]
\]

 Ce qui en Prolog donne :
\begin{lstlisting}[language=Prolog,frame=single]
?- membre(X, [1, 2, 3]).
\end{lstlisting}

On lis a ce moment que $X$ compose la liste constante $[1, 2, 3]$. Ainsi a
l'execution, Prolog peut evaluer les solutions de $L$ grace a cette proprietee
ainsi définie :

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(L, [1, 2, 3]).
L = 1;
L = 2;
L = 3;
false
\end{lstlisting}


\section{Reprouvabilitée multiple}

Une propriétée sur une variable par exemple, peut etre definit par plusieur
predicats. Par exemple~:
\[
    \left\{  
    \begin{array}{c}
        L \in [1, 2, 3]\\
        L \in [3, 4, 2]\\
    \end{array}
    \right .
\]

Cela revient simplement a l'ecriture en Prolog :
\begin{lstlisting}[language=Prolog,frame=single]
?- membre(L, [1, 2, 3]), membre(L, [3, 4, 2]).
L = 2;
L = 3;
false
\end{lstlisting}


\section{Reprouvabilitée non-déterministe}

La dangeureusitee de de la reprouvabilitée, est qu'il est possible qu'une
infinitée de solutions vérifient une meme propriétée. Considerons par exemple
le code suivant~:

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, L).
\end{lstlisting}

Cette est equivalent à $1 \in L$. Mais alors, combien de listes
pourraient vérifié cette propriété ?

\textbf{Initialisation}~: Une liste telle que $[1, 2]$ vérifie cette propriété.

\textbf{Hérédité}~: En notant $cat(A, B)$ la concatenation de deux listes $A$ et
$B$,\\
Soit une liste $L$ telle que $1 \in L$,\\
Alors $\forall X \in \mathbb{N} / 1 \in cat([X], L)$

\textbf{Conclusion}~: Il éxiste une infinité de solutions et Prolog va essayer
de toutes les générer, causant une exception du au manque de mémoire de la
machine.

\begin{lstlisting}[language=Prolog,frame=single]
?- membre(1, L).
L = [1|_G2214] ;
L = [_G2213, 1|_G2217] ;
L = [_G2213, _G2216, 1|_G2220] ;
L = [_G2213, _G2216, _G2219, 1|_G2223] ;
L = [_G2213, _G2216, _G2219, _G2222, 1|_G2226] ;
L = [_G2213, _G2216, _G2219, _G2222, _G2225, 1|_G2229] ;
...
\end{lstlisting}


\section{Programation de prédicats}

Au paravant, nous fesions que utiliser des prédicats, mais bien entendu,
l'objectif est de pouvoir coder les siens. Pour cela, interessons nous a la
reecriture de
\[(membre(X, L) \Leftrightarrow vrai) \Leftrightarrow X \in L\]

\begin{lstlisting}[language=Prolog,frame=single]
membre(X, [X|_]).
membre(X, [_|L]) :- membre(X, L).
\end{lstlisting}
